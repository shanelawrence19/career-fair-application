// This is a file that is essentially our csv parser functionality. Here we take the reports generated by career services,
// parse them for the company profile data, and populate our DB table related to the companies with the info gathered.

// ADDED: I found an import that seems like it can cover parsing a lot better than I can manually, so I'm going to try using it instead.
import Papa from "papaparse"; 

// Create a data structure for a "Company"
export type Company = {
    // Here are the fields we would need to populate for company profiles.
    orgName: string;
    logo?: string; // This one I'm not so sure about since we don't have an example to work with, data type might need changed
    majors: string[];
    posTitles: string[];
    posTypes: string[];
    compDesc?: string;
    website?: string;
    visaSponsorship?: string;
}

// Get the total number of companies
export type ParseOutput = { companies: Company[]; total: number };

// This is a list of the header names, so that they can be easily changed or addended
export type HeaderMap = {
    orgName: string;
    logo: string;
    majors: string;
    posTitles: string;
    posTypes: string;
    compDesc: string;
    website: string;
    visaSponsorship: string;
}

export const defaultHeaderMap: HeaderMap = {
  orgName: "Organization Name",
  logo: "Logo",
  majors: "Majors",
  posTitles: "Position Titles",
  posTypes: "Position Types",
  compDesc: "Company Description",
  website: "Website",
  visaSponsorship: "Visa Sponsorship",
};

/*
Need to convert the fields into actual array structures
"Computer Science; Software Engineering" -> ["Computer Science", "Software Engineering"]
This does it using both semicolons and commas as seperators.
*/
const fieldsAsList = (s?: string | null): string[] =>
(s ?? "").split(/[;,]/).map(x => x.trim()).filter(Boolean);
// It is a super complex line for no real reason, it essentially is checking whether a field exists, converting it to a string if it does,
// splitting it by either semicolons or commas, trimming the whitespace, and filtering out any blank entries.

/*
This is a grabber for cells
*/
const getCell = (row: string[], colIndex: number): string | undefined =>
  colIndex >= 0 && colIndex < row.length ? row[colIndex] : undefined;

/*
This is the actual parser logic. Uses our pre-made list of headers.
*/
export function parseCompaniesFromCsv(opts: {
    csvText: string;
    headermap?: HeaderMap;
}): ParseOutput {
    const headerMap = opts.headermap ?? defaultHeaderMap;
    // Set the CSV to our text we need to parse
    const {csvText} = opts;
    // If the text is empty/ does not exist, then there are no companies.
    if (!csvText || csvText.trim() === "") {
        return { companies: [], total: 0 };
    }

    // Use PapaParse to parse the CSV text
    const parsed = Papa.parse<string[]>(csvText, {
        header: false,
        skipEmptyLines: true,
    });

    const rows = parsed.data;
    if (rows.length === 0) {
        return { companies: [], total: 0 };
    }

    // Get the header row
    const headerRow = rows[0];
    // Map headers to their column
    const headerIndices: { [key: string]: number } = {};
    Object.entries(headerMap).forEach(([key, headerName]) => {
        const colIndex = headerRow.indexOf(headerName);
        headerIndices[key] = colIndex;
    });

    const companies: Company[] = [];

    // Build our company objects from each row
    for (let i = 1; i < rows.length; i++) {
        const row = rows[i];
        const company: Company = {
            orgName: getCell(row, headerIndices.orgName) || "",
            logo: getCell(row, headerIndices.logo),
            majors: fieldsAsList(getCell(row, headerIndices.majors)),
            posTitles: fieldsAsList(getCell(row, headerIndices.posTitles)),
            posTypes: fieldsAsList(getCell(row, headerIndices.posTypes)),
            compDesc: getCell(row, headerIndices.compDesc),
            website: getCell(row, headerIndices.website),
            visaSponsorship: getCell(row, headerIndices.visaSponsorship),
        };
        companies.push(company);
    }

    return { companies, total: companies.length };
}